import time
import sys
global loaded_pokemon
loaded_pokemon = []
#pokedex class
class Pokedex():
    #initialising attributes
    def __init__(self):
        self.PokemonList = []
        
    #for adding a pokemon to the pokemon list
    def AddPokemon(self):
        NewPokemon = Pokemon.create_Pokemon()
        self.PokemonList.append(NewPokemon)
        print("{0} added to pokedex!".format(NewPokemon.name))
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        """StartMenu(trainer1)"""
    
    #adding the pokemon's edited state
    #creating the edited pokemon variable to temporarily store the pokemon for editing
    #actually this method is never called anymore, but it keeps breaking if i delete it so its staying right where it is
    def AddForEdit(self):
        edited_pokemon = Pokemon.Edit_Pokemon()
        self.PokemonList.append(edited_pokemon)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        """StartMenu(trainer1)"""
        
    #for adding the starter pokemon
    def Addprexisting(self, NewPokemon):
        self.PokemonList.append(NewPokemon)
    
    #for searching the pokemon up in the list
    def search(self, user_input):
        #found boolean
        found = False
        user_input = input("By name or type? ")
        if user_input.lower() == "type":
            type_input = input("What type are you looking for? ")
            for pokemon in self.PokemonList:
                if type_input.lower() in str(pokemon.Type).lower():
                    print("")
                    print("National Number: {0}".format(pokemon.National_number))
                    time.sleep(0.02)
                    print("Name: {0}".format(pokemon.name))
                    time.sleep(0.02)
                    print("Type: {0}".format(pokemon.Type))
                    time.sleep(0.02)
                    print("Species: {0}".format(pokemon.species))
                    time.sleep(0.02)
                    print("Height: {0}".format(pokemon.Height))
                    time.sleep(0.02)
                    print("Weight: {0}".format(pokemon.Weight))
                    time.sleep(0.02)
                    print("Abilities: {0}".format(pokemon.Abilities))
                    time.sleep(0.02)
                    print("HP: {0}".format(pokemon.hp))
                    time.sleep(0.02)
                    print("Attack: {0}".format(pokemon.attack))
                    time.sleep(0.02)
                    print("Special Attack: {0}".format(pokemon.sp_attack))
                    time.sleep(0.02)
                    print("Special Defense: {0}".format(pokemon.sp_defense))
                    time.sleep(0.02)
                    print("Speed: {0}".format(pokemon.speed))
                    time.sleep(0.02)
                    found = True
            if not found:
                print("sorry, that type does not exist")
            time.sleep(0.02)
            print(".")
            time.sleep(0.02)
            print(".")
            time.sleep(0.02)
            print(".")
            time.sleep(0.02)
            return
        user_input = input("What's the name of the Pokemon you wish to find? ")
        #looping over all the pokemon to search them all and compare them to the user input
        for pokemon in self.PokemonList:
            if pokemon.name.lower() == user_input.lower(): #outputs the pokemon description
                #redefined printing process for attributes for new concrete charmander class due to irregular number of attributes compared to the normal pokemon class
                print("National Number: {0}".format(pokemon.National_number))
                time.sleep(0.02)
                print("Name: {0}".format(pokemon.name))
                time.sleep(0.02)
                print("Type: {0}".format(pokemon.Type))
                time.sleep(0.02)
                print("Species: {0}".format(pokemon.species))
                time.sleep(0.02)
                print("Height: {0}".format(pokemon.Height))
                time.sleep(0.02)
                print("Weight: {0}".format(pokemon.Weight))
                time.sleep(0.02)
                print("Abilities: {0}".format(pokemon.Abilities))
                time.sleep(0.02)
                print("HP: {0}".format(pokemon.hp))
                time.sleep(0.02)
                print("Attack: {0}".format(pokemon.attack))
                time.sleep(0.02)
                print("Special Attack: {0}".format(pokemon.sp_attack))
                time.sleep(0.02)
                print("Special Defense: {0}".format(pokemon.sp_defense))
                time.sleep(0.02)
                print("Speed: {0}".format(pokemon.speed))
                time.sleep(0.02)
                #we found the pokemon
                found = True
                break
        #if we did not find the pokemon
        if not found:
            print("sorry, that pokemon does not exist")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        """StartMenu(trainer1)"""
    
    #for the initial call for Sing the pokemon, displays the pokemons current stats for clarity
    def edit(self):
        #basically the same as the search but calls for an edit aswell
        found_edit = False
        user_input = input("What's the name of the Pokemon you wish to edit? ")
        for index, pokemon in enumerate(self.PokemonList):
            #checking if the pokemon exists
            if pokemon.name.lower() == user_input.lower():
                #redefined printing process for attributes for new concrete charmander class due to irregular number of attributes compared to the normal pokemon class
                for attr, value in pokemon.__dict__.items():
                    print(f"{attr}: {value}")
                    time.sleep(0.02)
                '''print("Found: {0}".format(pokemon.name))
                time.sleep(0.02)
                print("Pokedex Number: {0}".format(pokemon.pokedex_number))
                time.sleep(0.02)
                print("Type: {0}".format(pokemon.Type))
                time.sleep(0.02)
                print("HP: {0}".format(pokemon.hp))
                time.sleep(0.02)
                print("Attack: {0}".format(pokemon.attack))
                time.sleep(0.02)
                print("Speed: {0}".format(pokemon.speed))
                time.sleep(0.02)
                print("Special Attack: {0}".format(pokemon.sp_attack))
                time.sleep(0.02)
                print("Special Defense: {0}".format(pokemon.sp_defense))'''
                found_edit = True
                print()
                #storing the edited pokemons information in a variable to manipulate (just so i can re-append it to the list properly)
                edited_pokemon = pokemon.Edit_Pokemon()
                self.PokemonList.append(edited_pokemon)
                return
                #removed print block to prevent duplicate prints
        #if we did not find the pokemon
        if not found_edit:
            print("sorry, that pokemon does not exist")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        """StartMenu(trainer1)"""
    
    def load_save_file(self, filename):
        try:
            with open(filename, 'r') as file:
                attributes_available = ["Name", "National Number", "Type", "Species", "Height", "Weight", "Abilities","Total", "HP", "Attack", "Defence", "Special Attack", "Special Defense", "Speed"]
                iteration = 0
                end = 0
                active_attributes = []
                global loaded_pokemon
                loaded_pokemon = []
                for line in file:
                    skip = False
                    if not line.strip():  # Skip empty lines
                        continue
                    if ':' not in line:   # Skip lines without ':'
                        continue
                    data = line.strip().split(': ')
                    if len(data) < 2:
                        continue  # Skip lines that don't have both key and value
                    key = data[0].strip()
                    value = data[1].strip()
                    if key == attributes_available[iteration - 1]:
                        passed = True
                        pass 
                    elif iteration == 2 and key != attributes_available[iteration]:
                        #debugging prints
                        '''print(f"expected {attributes_available[iteration]}, but got {key}. Setting Type to 'None'.")
                        print(data)'''
                        passed = False
                        skip = True
                        if attributes_available[iteration].lower() == "type":
                            active_attributes.append("None")  # Default value for missing Type
                            iteration += 1
                        
                        

                    if key in attributes_available:
                        if key == "Abilities":
                            value = [ability.strip() for ability in value.split(',')]
                        elif key in ["National_number", "hp", "attack", "Defense", "sp_attack", "sp_defense", "speed"]:
                            try:
                                value = int(value)
                            except ValueError:
                                print(f"Invalid integer for {key}, defaulting to 0.")
                                value = 0
                    active_attributes.append(value)
                    '''del active_attributes[iteration]'''

                    iteration += 1
                    #accounting for logic error in irteration counting
                    if iteration == 14:
                        end = 4

                    #2 different ways to end each pokemon's stat block, due to logic error in iteration counting
                    if iteration == 14:
                        #debugging prints
                        '''print(iteration)
                        print(active_attributes)'''
                        pokemon = Pokemon(*active_attributes)
                        loaded_pokemon.append(pokemon.name)
                        self.PokemonList.append(pokemon)
                        iteration = 0
                        active_attributes = []
                        end = 0
                    elif end == 4: 
                        pokemon = Pokemon(*active_attributes)
                        loaded_pokemon.append(pokemon.name)
                        self.PokemonList.append(pokemon)
                        iteration = 0
                        active_attributes = []
                        end = 0
            print("Save File loaded successfully.")
            print(loaded_pokemon)
        except FileNotFoundError:
            print("Save File not found.")


#pokemon class
class Pokemon():
    #init for class attributes, (pokemon stats)
    def __init__(self, name, National_number, Type, species, Height, Weight, Abilities, total, hp, attack, Defense, sp_attack, sp_defense, speed):
        self.hp = hp
        self.Defense = Defense
        self.Height = Height
        self.Weight = Weight
        self.Abilities = Abilities
        self.species = species
        self.attack = attack
        self.total = total
        self.name = name
        self.Type = Type
        self.National_number = National_number
        self.sp_attack = sp_attack
        self.sp_defense = sp_defense
        self.speed = speed
    
    #static method because calling self is painful for this and caused problems (idk why tbh)
    def create_Pokemon():
        #lists of current attributes available within a pokemon and the dictionary for storing the attribute values
        attributes_available = ["name", "National_number", "Type", "species", "Height", "Weight", "Abilities", "hp", "attack", "Defense", "sp_attack", "sp_defense", "speed"]
        int_attributes = ["National_number", "hp", "attack", "sp_attack", "sp_defense", "speed"]
        attribute_values = {}
        #loop for iterating over the attributes
        for i in range(len(attributes_available)):
            active_attribute = attributes_available[i]
            value = input("{0}: ".format(active_attribute))
            if active_attribute in int_attributes:       
                #error handling
                try:
                    value = int(value)
                except ValueError:
                    print("Invalid value for {0}, defaulted to 0.".format(active_attribute))
                    value = 0
            attribute_values[active_attribute] = value
            attribute_values["total"] = int(attribute_values.get("hp", 0)) + int(attribute_values.get("attack", 0)) + int(attribute_values.get("Defense", 0)) + int(attribute_values.get("sp_attack", 0)) + int(attribute_values.get("sp_defense", 0)) + int(attribute_values.get("speed", 0))
            #returning the values into one object
        return Pokemon(
            attribute_values["name"], #1
            attribute_values["National_number"], #2
            attribute_values["Type"], #3
            attribute_values["species"],    #4
            attribute_values["Height"], #5
            attribute_values["Weight"], #6
            attribute_values["Abilities"], #7
            attribute_values["total"], #8
            attribute_values["hp"], #9
            attribute_values["attack"], #10
            attribute_values["Defense"], #11
            attribute_values["sp_attack"], #12
            attribute_values["sp_defense"], #13
            attribute_values["speed"] #14
        )

        #old method kept because it was easier to understand and as backup if the looping method caused too many issues to warrant
        """name = input("Name: ")
        Type = input("Type: ")
        pokedex_number = input("Pokedex Number: ")
        Hp = input("HP: ")
        attack = input("attack: ")
        speed = input("speed: ")
        sp_attack = input("special attack: ")
        sp_defense = input("special defense: ")
        return Pokemon(pokedex_number ,name, Type, Hp, attack, speed,
                       sp_attack, sp_defense) """
    
    #editing method
    def Edit_Pokemon(self):
        attributes_available = ["name", "National_number", "species", "Height", "Weight", "Abilities", "hp", "attack", "Defense", "sp_attack", "sp_defense", "speed"]
        int_attributes = ["National_number", "hp", "attack", "Defense", "sp_attack", "sp_defense", "speed"]
        user_intput = input("which attribute would you like to change? ")
        if user_intput in attributes_available:
            if user_intput == "Abilities":
                print("Please enter the abilities as a comma-separated list (e.g., Ability1, Ability2):")
                new_value = input("New Abilities: ")
                new_value = [ability.strip() for ability in new_value.split(",")]
            else:
                new_value = input("Please enter the new value for {0} here: ".format(user_intput))
            if user_intput in int_attributes:
                try:
                    new_value = int(new_value)
                except ValueError:
                    print("Please enter an accepted value for this attribute")
                    print("Exiting edit mode.")
                    return self
            setattr(self, user_intput, new_value)
            print("{0} has been set to {1}".format(user_intput, new_value))
        else:
            print("Invalid attribute name")
        print("Exiting edit mode.")
        return self

#classes for types w/ polymorphism for creation and inheritance
#I see this as less efficient that what I previously had so i dont fully understand why I need to implament it but its in the assignemnt guidlines so its here
class Fire_Pokemon(Pokemon):
    def __init__(self,
                 name="default_name",
                 National_number=9999999,
                 Type="Fire",
                 species="none",
                 Height="0.0m",
                 Weight="0.0kg",
                 Abilities=["none"],
                 total=0,
                 hp=71.3,
                 attack=84.8,
                 defense=71.4,
                 sp_attack=88.8,
                 sp_defense=73.3,
                 speed=76.0
                 ):
        total = int(hp) + int(attack) + int(defense) + int(sp_attack) + int(sp_defense) + int(speed)
        super().__init__(name, National_number, species, Type, Height, Weight, Abilities, total, hp, attack, defense, sp_attack, sp_defense, speed)
        self.total = total
        self.Type = "Fire"


  
    def create_Pokemon():
        #lists of current attributes available within a pokemon and the dictionary for storing the attribute values
        attributes_available = ["name", "National_number", "species", "Height", "Weight", "Abilities", "hp", "attack", "Defense", "speed", "sp_attack", "sp_defense"]
        int_attributes = ["National_number", "hp", "attack", "speed", "sp_attack", "sp_defense", "Height", "Weight"]
        attribute_values = {}
        #loop for iterating over the attributes
        for i in range(len(attributes_available)):
            active_attribute = attributes_available[i]
            value = input("{0}: ".format(active_attribute))
            if active_attribute in int_attributes:
                #error handling
                try:
                    value = int(value)
                except ValueError:
                    print("Invalid value for {0}, defaulted to 0.".format(active_attribute))
                    value = 0
            attribute_values[active_attribute] = value
            #returning the values into one object
        return Fire_Pokemon(
            attribute_values["name"],
            attribute_values["National_number"],
            attribute_values["species"],
            attribute_values["Height"],
            attribute_values["Weight"],
            attribute_values["Abilities"],
            attribute_values["Type"],
            attribute_values["hp"],
            attribute_values["attack"],
            attribute_values["speed"],
            attribute_values["sp_attack"],
            attribute_values["sp_defense"]
        )

class Grass_Pokemon(Pokemon):
    def __init__(self,
                 name="default_name",
                 National_number=9999999,
                 Type="Grass",
                 species="none",
                 height="0.0m",
                 weight="0.0kg",
                 abilities=["none"],
                 total=0,
                 hp=72.0,
                 attack=70.0,
                 sp_attack=75.0,
                 sp_defense=75.0,
                 defense=72.0,
                 speed=68.0):
        total = int(hp) + int(attack) + int(defense) + int(sp_attack) + int(sp_defense) + int(speed)
        super().__init__(name, National_number, species, Type, height, weight, abilities, total, hp, attack, defense, sp_attack, sp_defense, speed)
        self.total = total
        self.Type = "Grass"

    def create_Pokemon():
        #lists of current attributes available within a pokemon and the dictionary for storing the attribute values
        attributes_available = ["name", "National_number", "species", "Height", "Weight", "Abilities", "hp", "attack", "Defense", "speed", "sp_attack", "sp_defense"]
        int_attributes = ["National_number", "hp", "attack", "speed", "sp_attack", "sp_defense", "Height", "Weight"]
        attribute_values = {}
        #loop for iterating over the attributes
        for i in range(len(attributes_available)):
            active_attribute = attributes_available[i]
            value = input("{0}: ".format(active_attribute))
            if active_attribute in int_attributes:
                #error handling
                try:
                    value = int(value)
                except ValueError:
                    print("Invalid value for {0}, defaulted to 0.".format(active_attribute))
                    value = 0
            attribute_values[active_attribute] = value
            #returning the values into one object
        return Grass_Pokemon(
            attribute_values["name"],
            attribute_values["National_number"],
            attribute_values["species"],
            attribute_values["Height"],
            attribute_values["Weight"],
            attribute_values["Abilities"],
            attribute_values["Type"],
            attribute_values["hp"],
            attribute_values["attack"],
            attribute_values["speed"],
            attribute_values["sp_attack"],
            attribute_values["sp_defense"]
        )

class Electric_Pokemon(Pokemon):
    def __init__(self,
                 name="default_name",
                 National_number=9999999,
                 Type="Electric",
                 species="none",
                 height="0.0m",
                 weight="0.0kg",
                 abilities=["none"],
                 total=0,
                 hp=65.0,
                 attack=80.0,
                 sp_attack=85.0,
                 sp_defense=70.0,
                 defense=60.0, 
                 speed=90.0
                 ):
        total = int(hp) + int(attack) + int(defense) + int(sp_attack) + int(sp_defense) + int(speed)
        super().__init__(name, National_number, species, Type, height, weight, abilities, total, hp, attack, defense, sp_attack, sp_defense, speed)
        self.total = total
        self.Type = "Electric"
    
    def create_Pokemon():
        #lists of current attributes available within a pokemon and the dictionary for storing the attribute values
        attributes_available = ["name", "National_number", "species", "Height", "Weight", "Abilities", "hp", "attack", "Defense", "speed", "sp_attack", "sp_defense"]
        int_attributes = ["National_number", "hp", "attack", "speed", "sp_attack", "sp_defense", "Height", "Weight"]
        attribute_values = {}
        #loop for iterating over the attributes
        for i in range(len(attributes_available)):
            active_attribute = attributes_available[i]
            value = input("{0}: ".format(active_attribute))
            if active_attribute in int_attributes:
                #error handling
                try:
                    value = int(value)
                except ValueError:
                    print("Invalid value for {0}, defaulted to 0.".format(active_attribute))
                    value = 0
            attribute_values[active_attribute] = value
            #returning the values into one object
        return Electric_Pokemon(
            attribute_values["name"],
            attribute_values["National_number"],
            attribute_values["species"],
            attribute_values["Height"],
            attribute_values["Weight"],
            attribute_values["Abilities"],
            attribute_values["Type"],
            attribute_values["hp"],
            attribute_values["attack"],
            attribute_values["speed"],
            attribute_values["sp_attack"],
            attribute_values["sp_defense"]
        )


#concrete classes for specific pokemon with unique attributes
#fire
class Charmander_Pokemon(Fire_Pokemon):
    def __init__(self, national_number=4, species="Lizard Pokemon", height="0.6m", weight="8.5kg", abilities=["Blaze", "Solar Power"]):
        super().__init__("Charmander", national_number, "Fire", species, height, weight, abilities, total=0, hp=39, attack=52, defense=43, speed=65, sp_attack=60, sp_defense=50)
        self.national_number = national_number
        self.species = species
        self.height = height
        self.weight = weight
        self.abilities = abilities

class Charizard_Pokemon(Fire_Pokemon):
    def __init__(self, national_number=6, species="Flame Pokemon", height="1.7m", weight="90.5kg", abilities=["Blaze", "Solar Power"]):
        super().__init__("Charizard", national_number, "Fire", species, height, weight, abilities, total=0, hp=78, attack=84, defense=78, speed=100, sp_attack=109, sp_defense=85)
        self.national_number = national_number
        self.species = species
        self.height = height
        self.weight = weight
        self.abilities = abilities

#grass
class Bulbasaur_Pokemon(Grass_Pokemon):
    def __init__(self, national_number=1, species="Seed Pokemon", height="0.7m", weight="6.9kg", abilities=["Overgrow", "Chlorophyll"]):
        super().__init__("Bulbasaur", national_number, "Grass", species, height, weight, abilities, total=0, hp=45, attack=49, defense=49, speed=45, sp_attack=65, sp_defense=65)
        self.national_number = national_number
        self.species = species
        self.height = height
        self.weight = weight
        self.abilities = abilities

class Ivysaur_Pokemon(Grass_Pokemon):
    def __init__(self, national_number=2, species="Seed Pokemon", height="1.0m", weight="13.0kg", abilities=["Overgrow", "Chlorophyll"]):
        super().__init__("Ivysaur", national_number, "Grass", species, height, weight, abilities, total=0, hp=60, attack=62, defense=60, speed=80, sp_attack=80, sp_defense=80)
        self.national_number = national_number
        self.species = species
        self.height = height
        self.weight = weight
        self.abilities = abilities

#electric
class Pikachu_Pokemon(Electric_Pokemon):
    def __init__(self, national_number=25, species="Mouse Pokemon", height="0.4m", weight="6.0kg", abilities=["Static", "Lightning Rod"]):
        super().__init__("Pikachu", national_number, "Electric", species, height, weight, abilities, total=0, hp=35, attack=55, defense=40, speed=90, sp_attack=50)
        self.national_number = national_number
        self.species = species
        self.height = height
        self.weight = weight
        self.abilities = abilities

class Raichu_Pokemon(Electric_Pokemon):
    def __init__(self, national_number=26, species="Mouse Pokemon", height="0.8m", weight="30.0kg", abilities=["Static", "Lightning Rod"]):
        super().__init__("Raichu", national_number, "Electric", species, height, weight, abilities, total=0, hp=60, attack=90, defense=55, speed=110, sp_attack=90, sp_defense=80)
        self.national_number = national_number
        self.species = species
        self.height = height
        self.weight = weight
        self.abilities = abilities

#trainer class
class Trainer():
    #init for class attributes, including the creation of a pokedex attatched directly to the trainer
    def __init__(self, name, City):
        self.name = name
        self.pokedex = City
        self.pokedex = Pokedex()  # Creating pokedex 
    
    #welcoming method
    def Welcome(self):
        #getting user input
        name = input("what is your name? ")
        City = input("Where Are you from? ")
        print("Welcome {0} from {1}. This is your pokedex!".format(name, City))
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        print(".")
        time.sleep(0.02)
        self.Starter_Pokemon()
        print("Hello, what would you like to do?")
        print(".")
        #calling menu
        StartMenu(trainer1)
    
    #starter pokemon everyone gets
    #only adds them if they are not already in the pokedex (to prevent duplicates for type reports)
    def Starter_Pokemon(self):

        Pikachu = Pikachu_Pokemon()
        Raichu = Raichu_Pokemon()
        Ivysaur = Ivysaur_Pokemon()
        Bulbasaur = Bulbasaur_Pokemon()
        Charmander = Charmander_Pokemon()
        Charizard = Charizard_Pokemon()
        if Pikachu.name not in loaded_pokemon:  
            self.pokedex.Addprexisting(Pikachu)
        if Bulbasaur.name not in loaded_pokemon:
            self.pokedex.Addprexisting(Bulbasaur)
        if Charmander.name not in loaded_pokemon:
            self.pokedex.Addprexisting(Charmander)
        if Raichu.name not in loaded_pokemon:
            self.pokedex.Addprexisting(Raichu)
        if Ivysaur.name not in loaded_pokemon:
            self.pokedex.Addprexisting(Ivysaur)
        if Charizard.name not in loaded_pokemon:
            self.pokedex.Addprexisting(Charizard)

#main menu
def StartMenu(trainer1):
    while True:
        user_input = ""
        print("=== Menu ===")
        time.sleep(0.02)
        print("Option 1: Create new pokedex entry")
        time.sleep(0.02)
        print("Option 2: Search pokedex for pokemon by name")
        time.sleep(0.02)
        print("Option 3: Edit pokemon data within pokedex")
        time.sleep(0.02)
        print("Option 4: Generate report of all pokemon of a certain type (e.g., Fire, Water, Grass, Electric)")
        time.sleep(0.02)
        print("Option Exit or X: Exits the program")
        user_input = input("")
        
        #option handling
        if user_input == ("1"):
            option_1(trainer1)
        elif user_input == ("2"):
            option_2(trainer1)
        elif user_input == ("3"):
            option_3(trainer1)
            break
        elif user_input.lower() == "list":
            for pokemon in trainer1.pokedex.PokemonList:
                print(pokemon.name)
        #generating type report
        elif user_input == ("4"):
            type_input = input(f"Which type would you like a report for?")
            filename = f"{type_input.lower()}.txt"
            with open(filename, "w") as file:
                for pokemon in trainer1.pokedex.PokemonList:
                    if pokemon.Type.lower() == type_input.lower():
                        abilities_str = ' '.join(pokemon.Abilities) if isinstance(pokemon.Abilities, list) else pokemon.Abilities
                        file.write("\n"
                                    f"name: {pokemon.name}\n"
                                f"National_number: {pokemon.National_number}\n"
                                f"Type: {pokemon.Type}\n"
                                f"species: {pokemon.species}\n"
                                f"Height: {pokemon.Height}\n"
                                f"Weight: {pokemon.Weight}\n"
                                f"abilities: {abilities_str}\n"
                                f"Stats:\n"
                                f"  total: {pokemon.total}\n"
                                f"  hp: {pokemon.hp}\n"
                                f"  attack: {pokemon.attack}\n"
                                f"  Defense: {pokemon.Defense}\n"
                                f"  sp_attack: {pokemon.sp_attack}\n"
                                f"  sp_defense: {pokemon.sp_defense}\n"
                                f"  speed: {pokemon.speed}\n\n")
            print(f"Type report saved successfully as {filename}.")
        #system exit option
        elif user_input.lower() == "exit" or user_input.lower() == "x":
            user_input = input("Would you like to save your current pokedex? (Y/N)")
            if user_input.lower() == "y":
                #make save file
                filename = input("What file name would you like to save it as? (default: pokemon.txt): ")
                if not filename:
                    filename = "pokemon.txt"
                open(filename, "a").close()
                with open(filename, "a") as file:
                    for pokemon in trainer1.pokedex.PokemonList:
                        # Skip already loaded Pokémon
                        if pokemon.name in loaded_pokemon:
                            continue  
                        abilities_str = ' '.join(pokemon.Abilities) if isinstance(pokemon.Abilities, list) else pokemon.Abilities
                        file.write("\n"
                                    f"name: {pokemon.name}\n"
                                    f"National_number: {pokemon.National_number}\n"
                                    f"Type: {pokemon.Type}\n"
                                    f"species: {pokemon.species}\n"
                                    f"Height: {pokemon.Height}\n"
                                    f"Weight: {pokemon.Weight}\n"
                                    f"abilities: {abilities_str}\n"
                                    f"Stats:\n"
                                    f"  total: {pokemon.total}\n"
                                    f"  hp: {pokemon.hp}\n"
                                    f"  attack: {pokemon.attack}\n"
                                    f"  Defense: {pokemon.Defense}\n"
                                    f"  sp_attack: {pokemon.sp_attack}\n"
                                    f"  sp_defense: {pokemon.sp_defense}\n"
                                    f"  speed: {pokemon.speed}\n\n")
                print("Pokedex saved successfully. Exiting now.")
                                    

                sys.exit()
            elif user_input.lower() == "n":
                print("OK, exiting without saving.")
                sys.exit()
        else:
            print("Sorry, that is not an option.Exiting now.")
            time.sleep(0.02)
            print("Please pick one of the available options")
            time.sleep(0.02)
            print("E.G. 1, 2, 3, Exit")
            """StartMenu(trainer1)"""

#option 1, handling new pokemon
def option_1(trainer1):
    print("OK!")
    print("lets add a new register.")
    print()
    trainer1.pokedex.AddPokemon()
    
#option 2, handling searches
def option_2(trainer1):
    print("OK!")
    print("lets search the registry!.")
    trainer1.pokedex.search(user_input="")

#options 3, handling editing a pokemon
def option_3(trainer1):
    print("OK!")
    print("lets edit the registry!.")
    print()
    trainer1.pokedex.edit()

#making the trainer object and pokedex objects that get handled in the main parts of the program



trainer1 = Trainer("", "")

def main():
    trainer1.pokedex.load_save_file("pokemon.txt")
    trainer1.Welcome()
    while True:
        StartMenu(trainer1)
        # If StartMenu returns (e.g., after exit), break the loop
        break

if __name__ == "__main__":
    main()
